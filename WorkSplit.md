### Инструменты и соглашения

1.  **Система контроля версий:** Git.
    *   **Основная ветка:** `main`. В нее сливается только полностью готовый и проверенный код.
    *   **Ветки разработки:** Каждый студент создает свою ветку для своей основной задачи (например, `feature/student-1-models`, `feature/student-2-algorithms`).
    *   **Слияние:** Все изменения вливаются в `main` через Pull/Merge Request'ы с обязательным Code Review от как минимум одного другого участника.
2.  **Среда разработки (IDE):** Любая (IntelliJ IDEA, Eclipse), но с **едиными настройками форматирования кода**. Это избавит от "шума" в коммитах из-за разного стиля.
3.  **Коммуникация:** Короткие ежедневные созвоны (5-10 минут) для обсуждения прогресса, проблем и планов на день.

---

### План выполнения

#### **Этап 1: Фундамент и контракты (1-2 дня)**

**Цель:** Создать каркас проекта и определить "контракты" (интерфейсы и публичные методы), чтобы все могли начать параллельную работу, не мешая друг другу.

**Задачи (выполняются совместно или одним ответственным):**

1.  **[Ответственный: Team Lead/Студент 4]** Создать Git-репозиторий, настроить базовую структуру проекта (пакеты `model`, `sort`, `service`, `search` и т.д.) и добавить `.gitignore`.
2.  **[Вся команда]** Обсудить и определить:
    *   **Интерфейс для сортировки:** `SortStrategy<T>`. Определить его метод `sort(...)`.
    *   **Сигнатуры кастомных классов:** Какие поля и геттеры будут у `Student`, `Bus`, `User`.
    *   **Сигнатуры классов-сервисов:** Какие публичные методы будут у классов, отвечающих за чтение/запись файла и генерацию данных.
3.  **[Все студенты]** Создать свои личные ветки от `main`.

**Результат этапа:** Пустой, но компилируемый проект с интерфейсами и "заглушками" классов. Все участники понимают, какие методы будут реализовывать их коллеги.

---

#### **Этап 2: Параллельная разработка основного функционала (3-5 дней)**

Теперь каждый студент может работать в своей ветке над независимым модулем.

**[Студент 1: "Владелец моделей"]**

*   **Задача:** Полная реализация кастомных классов.
*   **Детали:**
    *   Реализовать классы `Student`, `Bus`, `User`.
    *   В каждом классе реализовать паттерн **Builder** с **валидацией** в методе `build()`.
    *   Переопределить `toString()`, `equals()`, `hashCode()`.
    *   Реализовать интерфейс `Comparable` для сортировки "по умолчанию".
    *   Создать по 2-3 отдельных класса `Comparator` для каждого кастомного класса для сортировки по разным полям.

**[Студент 2: "Эксперт по алгоритмам"]**

*   **Задача:** Реализация универсальных алгоритмов сортировки и поиска.
*   **Детали:**
    *   Реализовать класс `QuickSort<T>`, имплементирующий интерфейс `SortStrategy<T>`.
    *   Реализовать статический generic-метод `BinarySearch.search(...)`.
    *   **Важно:** Написать для своих алгоритмов **ручные тесты** в отдельном классе, используя простые типы (`Integer`, `String`), чтобы не ждать готовности кастомных классов от Студента 1.

**[Студент 3: "Специалист по данным"]**

*   **Задача:** Реализация логики заполнения коллекций и работы с файлами.
*   **Детали:**
    *   Создать класс/сервис для **заполнения массива**:
        *   Метод для ручного ввода с консоли (`Scanner`).
        *   Метод для случайной генерации данных (`Random`).
        *   Метод для чтения из файла с **валидацией** данных в каждой строке (пропуск некорректных строк с выводом ошибки).
    *   Реализовать логику **записи результатов в файл** в режиме добавления (**Доп. задание 2**).

**[Студент 4: "Интегратор и архитектор"]**

*   **Задача:** Создание каркаса приложения и реализация многопоточности.
*   **Детали:**
    *   Создать основной класс `Main` с **циклическим меню** и логикой выхода.
    *   Реализовать класс `Sorter<T>`, который принимает в конструкторе `SortStrategy<T>`.
    *   В классе `Sorter<T>` реализовать метод, который выполняет сортировку в **ThreadPool** (`ExecutorService`).
    *   Подготовить "заглушки" в меню для вызова функционала других студентов.

---

#### **Этап 3: Интеграция и первое тестирование (1-2 дня)**

**Цель:** Собрать все части воедино и заставить их работать вместе.

1.  **[Все по очереди]** Студенты по одному вливают свои ветки в `main` через Pull Request'ы. **Порядок слияния важен:**
    1.  Сначала **Студент 1** (модели), так как они нужны всем.
    2.  Затем **Студент 2** (алгоритмы).
    3.  Потом **Студент 3** (данные).
    4.  Последним **Студент 4** (интегратор), который свяжет все вызовы в меню.
2.  **[Вся команда]** Совместное тестирование и отладка. На этом этапе неизбежно появятся баги интеграции. Задача — исправить их.

**Результат этапа:** Рабочее приложение с базовым функционалом.

---

#### **Этап 4: Параллельная разработка дополнительных заданий (2-3 дня)**

Теперь команда снова может работать параллельно над оставшимися задачами.

*   **[Студент 1]** Реализация **специальной сортировки** (**Доп. задание 1**).
*   **[Студент 2]** Реализация **многопоточного подсчета вхождений** элемента (**Доп. задание 4**).
*   **[Студент 3]** Рефакторинг заполнения коллекций с использованием **Stream API** (**Доп. задание 3**).
*   **[Студент 4]** Написание полноценных **ручных тестов** в отдельных классах для всех основных функций приложения. Организация логирования операций.

---

#### **Этап 5: Финализация (1 день)**

1.  **[Все по очереди]** Слияние последних веток с дополнительными заданиями в `main`.
2.  **[Вся команда]** Финальное сквозное тестирование всего приложения.
3.  **[Все]** Чистка кода, добавление комментариев, написание `README.md` файла с описанием проекта.

Этот план позволяет максимально распараллелить работу и четко определить зону ответственности каждого участника, что значительно повышает шансы на успешное и своевременное завершение проекта.