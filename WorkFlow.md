### Шаг 1: Структура проекта и настройка среды

```
src
├── main
│   ├── java
│   │   └── com
│   │       └── yourproject
│   │           ├── Main.java              // Точка входа и меню
│   │           ├── model                  // Кастомные классы (Student, Bus, User)
│   │           │   ├── Student.java
│   │           │   ├── Bus.java
│   │           │   └── User.java
│   │           ├── service                // Бизнес-логика (заполнение, запись в файл)
│   │           │   ├── DataGenerator.java
│   │           │   └── FileManager.java
│   │           ├── sort                   // Все, что связано с сортировкой
│   │           │   ├── strategy           // Паттерн Strategy
│   │           │   │   ├── SortStrategy.java
│   │           │   │   └── QuickSort.java
│   │           │   └── sorter             // Класс, использующий стратегию
│   │           │       └── Sorter.java
│   │           ├── search                 // Алгоритмы поиска
│   │           │   └── BinarySearch.java
│   │           └── util                   // Вспомогательные классы (валидаторы)
│   │               └── Validator.java
│   └── resources
│       └── data.txt                       // Файл с данными для загрузки
└── test
    └── java
        └── com
            └── yourproject
                ├── SortTest.java
                └── SearchTest.java
```

### Шаг 2: Кастомные классы с Builder и валидацией

Все три класса (`Student`, `Bus`, `User`) должны быть похожи. Реализуем на примере `Student`.

**Основные моменты:**
*   **Приватный конструктор:** Чтобы заставить пользователя создавать объект только через Builder.
*   **Статический вложенный Builder:** Внутренний класс, который накапливает поля и в методе `build()` создает основной объект.
*   **Валидация:** Проверка данных происходит в методе `build()` билдера перед созданием объекта.
*   **Comparable:** Для возможности "сортировки по умолчанию".


**Важно:** Для сортировки по трем разным полям создайте отдельные классы `Comparator`. Например, `Comparator<Student>` для сортировки по среднему баллу и по номеру зачетки.

### Шаг 3: Алгоритмы сортировки и поиска (Дженерики и Strategy)

**1. Паттерн Strategy для сортировки**

Создайте интерфейс, который определяет операцию сортировки.

**2. Реализация быстрой сортировки (QuickSort)**

Это будет ваша конкретная стратегия. Она должна быть обобщенной (`<T>`).

**3. Бинарный поиск с дженериками**

**Важно:** Бинарный поиск требует, чтобы коллекция была предварительно отсортирована по тому же самому критерию (компаратору), по которому ведется поиск.

### Шаг 4: Многопоточность с ThreadPool

Для выполнения сортировки в нескольких потоках используйте `ExecutorService`.

**`Sorter.java` (Класс, который использует стратегию)**

**Примечание:** Полноценная параллельная реализация самого алгоритма QuickSort (когда подзадачи рекурсии уходят в разные потоки) значительно сложнее. Представленный выше вариант выполняет всю сортировку в одном из потоков пула, что соответствует требованию "Выполнение в ThreadPool".

### Шаг 5: Способы заполнения массива

Создайте класс `DataGenerator`, который будет отвечать за создание и заполнение списков.

*   **Ручной ввод:** Используйте `Scanner` в цикле, запрашивая у пользователя каждое поле.
*   **Случайное заполнение:** Используйте класс `Random` для генерации чисел и случайных строк.
*   **Из файла:** Читайте файл построчно (`Files.lines` или `BufferedReader`). Каждую строку разбивайте (например, по запятой `.split(",")`). Обязательно оберните парсинг данных в `try-catch` для валидации. Если строка невалидна, пропустите ее и выведите сообщение об ошибке.

### Шаг 6: Меню и основная логика

В классе `Main` организуйте основной цикл программы.


### Шаг 7: Реализация дополнительных заданий

*   **Задание 1 (Сортировка четных):**
    1.  Создайте новый `List`.
    2.  Пройдитесь по исходному списку. Если у объекта значение числового поля четное, добавьте его в новый список.
    3.  Отсортируйте новый список (с четными значениями).
    4.  Снова пройдитесь по исходному списку. Если у объекта значение четное, замените его на следующий элемент из отсортированного списка четных.

*   **Задание 2 (Запись в файл):** Используйте `Files.write` с опцией `StandardOpenOption.APPEND`.

*   **Задание 3 (Стримы):** Вместо цикла `for` для генерации случайных данных можно использовать стримы.

*   **Задание 4 (Многопоточный подсчет):**
    1.  Разделите список на части (по количеству потоков).
    2.  Создайте `Callable<Integer>`, который будет считать вхождения в своей части списка.
    3.  Запустите все задачи через `threadPool.invokeAll()`.
    4.  Просуммируйте результаты, полученные из объектов `Future`.

### Шаг 8: Тестирование

Создайте в папке `test` классы, например `SortTest.java`